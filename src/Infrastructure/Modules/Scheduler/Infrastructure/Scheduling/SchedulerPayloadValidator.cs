using System.Text.Json;
using Application.Abstractions.Scheduler;
using Domain.Scheduler;

namespace Infrastructure.Scheduler;

internal sealed class SchedulerPayloadValidator : ISchedulerPayloadValidator
{
    private static readonly JsonSerializerOptions SerializerOptions = new(JsonSerializerDefaults.Web);

    public SchedulerPayloadValidationResult Validate(JobType type, string? payloadJson)
    {
        return type switch
        {
            JobType.GenericNoOp => ValidateGeneric(payloadJson),
            JobType.CleanupOldSchedulerExecutions => ValidateCleanup(payloadJson),
            JobType.NotificationDispatchProbe => ValidateNotificationProbe(payloadJson),
            _ => new SchedulerPayloadValidationResult(false, null, $"Unsupported job type '{type}'.")
        };
    }

    private static SchedulerPayloadValidationResult ValidateGeneric(string? payloadJson)
    {
        if (string.IsNullOrWhiteSpace(payloadJson))
        {
            return new SchedulerPayloadValidationResult(true, "{\"note\":\"no-op\"}", null);
        }

        try
        {
            GenericPayload payload = JsonSerializer.Deserialize<GenericPayload>(payloadJson, SerializerOptions) ?? new GenericPayload("no-op", null);
            int? delaySeconds = payload.DelaySeconds.HasValue
                ? Math.Clamp(payload.DelaySeconds.Value, 0, 600)
                : null;
            string normalized = JsonSerializer.Serialize(new GenericPayload(payload.Note ?? "no-op", delaySeconds), SerializerOptions);
            return new SchedulerPayloadValidationResult(true, normalized, null);
        }
        catch (JsonException)
        {
            return new SchedulerPayloadValidationResult(false, null, "Invalid payloadJson for GenericNoOp.");
        }
    }

    private static SchedulerPayloadValidationResult ValidateCleanup(string? payloadJson)
    {
        try
        {
            CleanupPayload payload = string.IsNullOrWhiteSpace(payloadJson)
                ? new CleanupPayload(14)
                : (JsonSerializer.Deserialize<CleanupPayload>(payloadJson, SerializerOptions) ?? new CleanupPayload(14));

            int retentionDays = payload.RetentionDays is >= 1 and <= 3650 ? payload.RetentionDays.Value : 14;
            string normalized = JsonSerializer.Serialize(new CleanupPayload(retentionDays), SerializerOptions);
            return new SchedulerPayloadValidationResult(true, normalized, null);
        }
        catch (JsonException)
        {
            return new SchedulerPayloadValidationResult(false, null, "Invalid payloadJson for CleanupOldSchedulerExecutions.");
        }
    }

    private static SchedulerPayloadValidationResult ValidateNotificationProbe(string? payloadJson)
    {
        try
        {
            ProbePayload payload = string.IsNullOrWhiteSpace(payloadJson)
                ? new ProbePayload("scheduler-probe@local.test", "Scheduler Probe", "Probe notification generated by scheduler.")
                : (JsonSerializer.Deserialize<ProbePayload>(payloadJson, SerializerOptions)
                   ?? new ProbePayload("scheduler-probe@local.test", "Scheduler Probe", "Probe notification generated by scheduler."));

            string recipient = string.IsNullOrWhiteSpace(payload.Recipient)
                ? "scheduler-probe@local.test"
                : payload.Recipient.Trim();

            if (!recipient.Contains('@', StringComparison.Ordinal))
            {
                return new SchedulerPayloadValidationResult(false, null, "NotificationDispatchProbe recipient must be an email-like value.");
            }

            var normalizedPayload = new ProbePayload(
                recipient,
                string.IsNullOrWhiteSpace(payload.Subject) ? "Scheduler Probe" : payload.Subject.Trim(),
                string.IsNullOrWhiteSpace(payload.Body) ? "Probe notification generated by scheduler." : payload.Body.Trim());

            string normalized = JsonSerializer.Serialize(normalizedPayload, SerializerOptions);
            return new SchedulerPayloadValidationResult(true, normalized, null);
        }
        catch (JsonException)
        {
            return new SchedulerPayloadValidationResult(false, null, "Invalid payloadJson for NotificationDispatchProbe.");
        }
    }

    private sealed record GenericPayload(string? Note, int? DelaySeconds);
    private sealed record CleanupPayload(int? RetentionDays);
    private sealed record ProbePayload(string? Recipient, string? Subject, string? Body);
}
