using System.Text.Json;
using Application.Scheduler;
using Domain.Modules.Scheduler;
using Domain.Scheduler;
using Infrastructure.Database;
using Microsoft.EntityFrameworkCore;

namespace Infrastructure.Scheduler;

public sealed class SchedulerDataSeeder(
    ApplicationDbContext dbContext,
    SchedulerOptions options)
{
    public async Task SeedAsync(CancellationToken cancellationToken)
    {
        if (!options.SeedDefaults)
        {
            return;
        }

        ScheduledJob cleanup = await UpsertJobAsync(
            "scheduler-cleanup-executions",
            "Cleanup old scheduler executions based on retention policy.",
            JobType.CleanupOldSchedulerExecutions,
            JsonSerializer.Serialize(new { retentionDays = 14 }),
            cancellationToken);

        await UpsertScheduleAsync(
            cleanup.Id,
            ScheduleType.Cron,
            intervalSeconds: null,
            oneTimeAtUtc: null,
            cronExpression: "0 */30 * * * *",
            cancellationToken: cancellationToken);

        ScheduledJob probe = await UpsertJobAsync(
            "scheduler-notification-probe",
            "Creates a probe notification message for operational monitoring.",
            JobType.NotificationDispatchProbe,
            JsonSerializer.Serialize(new
            {
                recipient = "ops@local.test",
                subject = "Scheduler Probe",
                body = "Probe notification generated by scheduler."
            }),
            cancellationToken);

        await UpsertScheduleAsync(
            probe.Id,
            ScheduleType.Cron,
            intervalSeconds: null,
            oneTimeAtUtc: null,
            cronExpression: "0 */15 * * * *",
            cancellationToken: cancellationToken);

        ScheduledJob oneTime = await UpsertJobAsync(
            "scheduler-welcome-once",
            "One-time welcome probe run after deployment.",
            JobType.GenericNoOp,
            JsonSerializer.Serialize(new { note = "seeded one-time job" }),
            cancellationToken);

        await UpsertScheduleAsync(
            oneTime.Id,
            ScheduleType.OneTime,
            intervalSeconds: null,
            oneTimeAtUtc: DateTime.UtcNow.AddMinutes(10),
            cronExpression: null,
            cancellationToken: cancellationToken);

        await UpsertDependencyAsync(oneTime.Id, probe.Id, cancellationToken);
        await dbContext.SaveChangesAsync(cancellationToken);
    }

    private async Task<ScheduledJob> UpsertJobAsync(
        string name,
        string description,
        JobType type,
        string? payloadJson,
        CancellationToken cancellationToken)
    {
        ScheduledJob? job = await dbContext.ScheduledJobs
            .SingleOrDefaultAsync(x => x.Name == name, cancellationToken);

        if (job is null)
        {
            job = new ScheduledJob
            {
                Id = Guid.NewGuid(),
                Name = name,
                Description = description,
                Type = type,
                PayloadJson = payloadJson,
                Status = JobStatus.Active,
                CreatedAtUtc = DateTime.UtcNow,
                MaxRetryAttempts = 3,
                RetryBackoffSeconds = 10,
                MaxExecutionSeconds = 120,
                MaxConsecutiveFailures = 5
            };
            dbContext.ScheduledJobs.Add(job);
            return job;
        }

        job.Description = description;
        job.Type = type;
        job.PayloadJson = payloadJson;
        if (job.Status == JobStatus.Inactive)
        {
            job.Status = JobStatus.Active;
        }

        return job;
    }

    private async Task UpsertScheduleAsync(
        Guid jobId,
        ScheduleType type,
        int? intervalSeconds,
        DateTime? oneTimeAtUtc,
        string? cronExpression,
        CancellationToken cancellationToken)
    {
        JobSchedule? schedule = await dbContext.JobSchedules
            .SingleOrDefaultAsync(x => x.JobId == jobId, cancellationToken);

        if (schedule is null)
        {
            schedule = new JobSchedule
            {
                Id = Guid.NewGuid(),
                JobId = jobId,
                CreatedAtUtc = DateTime.UtcNow
            };
            dbContext.JobSchedules.Add(schedule);
        }

        schedule.Type = type;
        schedule.IntervalSeconds = intervalSeconds;
        schedule.OneTimeAtUtc = oneTimeAtUtc;
        schedule.CronExpression = cronExpression;
        schedule.IsEnabled = true;
        schedule.StartAtUtc = DateTime.UtcNow;
        schedule.EndAtUtc = null;
        schedule.MisfirePolicy = MisfirePolicy.FireNow;
        schedule.MaxCatchUpRuns = 5;
        schedule.RetryAttempt = 0;
        schedule.NextRunAtUtc = ComputeInitialNextRun(type, intervalSeconds, oneTimeAtUtc, cronExpression);
        schedule.UpdatedAtUtc = DateTime.UtcNow;
    }

    private async Task UpsertDependencyAsync(Guid jobId, Guid dependsOnJobId, CancellationToken cancellationToken)
    {
        bool exists = await dbContext.JobDependencies
            .AnyAsync(x => x.JobId == jobId && x.DependsOnJobId == dependsOnJobId, cancellationToken);

        if (!exists)
        {
            dbContext.JobDependencies.Add(new JobDependency
            {
                Id = Guid.NewGuid(),
                JobId = jobId,
                DependsOnJobId = dependsOnJobId,
                CreatedAtUtc = DateTime.UtcNow
            });
        }
    }

    private static DateTime? ComputeInitialNextRun(ScheduleType type, int? intervalSeconds, DateTime? oneTimeAtUtc, string? cronExpression)
    {
        return SchedulerCalculations.ComputeNextRunUtc(
            type,
            cronExpression,
            intervalSeconds,
            oneTimeAtUtc,
            DateTime.UtcNow);
    }
}
