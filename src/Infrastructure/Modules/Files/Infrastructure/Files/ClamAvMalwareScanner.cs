using System.Buffers.Binary;
using System.Net.Sockets;
using System.Text;

namespace Infrastructure.Files;

internal sealed class ClamAvMalwareScanner(ClamAvOptions options) : IFileMalwareScanner
{
    private const int ChunkSize = 8192;

    public async Task<FileScanResult> ScanAsync(Stream content, CancellationToken cancellationToken)
    {
        if (!options.Enabled)
        {
            return new FileScanResult(true, "Scanner disabled.");
        }

        using var tcpClient = new TcpClient();
        using var timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
        timeoutCts.CancelAfter(TimeSpan.FromSeconds(Math.Max(5, options.TimeoutSeconds)));

        await tcpClient.ConnectAsync(options.Host, options.Port, timeoutCts.Token);
        await using NetworkStream stream = tcpClient.GetStream();

        byte[] inStreamCommand = Encoding.ASCII.GetBytes("zINSTREAM\0");
        await stream.WriteAsync(inStreamCommand, timeoutCts.Token);

        byte[] buffer = new byte[ChunkSize];
        int read;
        byte[] lengthPrefix = new byte[4];
        while ((read = await content.ReadAsync(buffer, timeoutCts.Token)) > 0)
        {
            BinaryPrimitives.WriteInt32BigEndian(lengthPrefix, read);
            await stream.WriteAsync(lengthPrefix.AsMemory(), timeoutCts.Token);
            await stream.WriteAsync(buffer.AsMemory(0, read), timeoutCts.Token);
        }

        await stream.WriteAsync(new byte[4], timeoutCts.Token);
        await stream.FlushAsync(timeoutCts.Token);

        byte[] responseBuffer = new byte[1024];
        int responseLength = await stream.ReadAsync(responseBuffer, timeoutCts.Token);
        string response = Encoding.UTF8.GetString(responseBuffer, 0, responseLength);

        bool clean = response.Contains("OK", StringComparison.OrdinalIgnoreCase) &&
                     !response.Contains("FOUND", StringComparison.OrdinalIgnoreCase);

        return new FileScanResult(clean, response.Trim());
    }
}
